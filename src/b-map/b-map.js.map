{"version":3,"sources":["b-map/b-map.coffee","b-map/b-map.js"],"names":[],"mappings":"AAAA;EAAA;;EAAA;;EAEA,gBAAe,QAAA;ICIX;EDJuB;;EAI3B,gBAAe,YAAA,GAAgB,UAAA;ICI3B;EDJ2B,CAA/B,CAAA;;EAIA,gBAAe,KAAA,GAAS,OAAA;IACtB;MAEE;MAAA;MACA;MCIE;QDFA;QAAA;QACA;QACA;QACA;QACA;QCKE;UDHA;UAAA;YACE;YACA;YACA;YACA;YACA;cACE;cACA;cACA;cACA;cACA;YCMA;UACF;UACA;QDnBW;MANjB;IAJa;IAwBf;EAzBsB,CAAxB,CAAA;;EA2BA,gBAAe,WAAA,GAAe,mEAAA;IAC5B;IAAA;MACE;MAAA;MAEA;MACA;MAEA;QCWI;MDX8B;MAClC;QCaI;MDbgC;MACpC;QCeI;MDfgC;MAEpC;MAGA;MAGA;MAGA;MAIA;MACA;QCOI;UACE;QDNe;MADX;QAIN;QAAA;UAA4C;QCS5C;QDRA;QACA;QACA;QCUA;MDfG;MAQP;QACE;QACA;QACA;QACA;QACA;QACA;QACA;MCUA;MACA;IDrDQ;ICuDV;EDxD0B,CAA9B,CAAA;;EAiDA,kBAAiB,IAAA,GAAQ,gDAAA;ICWrB;MDVF;MACA;MACA;QACE;QAAA;QACA;QACA;QACA;UACE;UAAA;YACE;YAEA;cACe;gBCaP;cACF;YDdE;cCgBF;YDbW;cCeX;YDdW;cCgBX;YDfW;YAEjB;cCgBM;YDdO;cCgBP;YDfU;YAEhB;UCgBE;QDjCoB;QAqB1B;QACA;QACA;UAAgB;UAAQ;UAAQ;QCkB5B;QDhBJ;QAEA;QAEA;QACA;QACA;QAEA;QAIA;QAEA;QAKA;UCOM;YDNJ;YCQM;UDTS;QAAP;QAIV;UACE;UAAA;UAEA;YACE;YAAA;YACA;YAAmB;YACnB;YAAoB;YCYhB;UDf0C;UAMhD;UAEA;UAEA;YCUM;UDTyE;UAI/E;UACA;YCQM;UDJU;UAChB;YCMM;UDJO;YCMP;UDLU;UAChB;YACe;cCOP;YACF;UDRE;YCUF;UDRW;YCUX;UDTW;YCWX;UDVW;UAEjB;YACE;YAAA;cACE;cACA;cACA;cACA;YCYE;cDVF;cACA;cACA;cACA;YCYE;YDVJ;YAKA;UAjBK;UAwBP;UACA;UAEA;YACE;YACA;YAGA;UALU;UAQZ;YCDM;UDCa;UAEnB;YACE;YAAA;YAEA;cCAM;YDGQ;cCDR;YDEQ;YACd;cCAM;YDCO;cAET;cAAA;cACA;gBCCI;cACF;gBACE;cACF;gBACE;cACF;YDRO;UAVR;UAeP;QAvFO;QA0FT;MA9II;ICqJJ;EDxJqB,CAAzB,CAAA;;AC2JA","file":"b-map/b-map.js","sourcesContent":["module = angular.module 'B.Map', []\n\nmodule.factory 'topojson', ->\n  topojson\n\n# load topojson\nmodule.factory 'bTopojsonSvc', ($http) ->\n  $http.get '../dist/ne_110m_admin_0_countries_topojson.json'\n\n# extend d3 w/ collission func\nmodule.factory 'd3map', (d3) ->\n  d3.collision = (alpha, nodes, radiusKey, bubblePadding, w, h) ->\n    # alpha controls how hard nodes collide & how far they're pushed\n    radiusKey = 'r' + radiusKey\n    quadtree = d3.geom.quadtree nodes\n    (node) ->\n      nr = node[radiusKey] + bubblePadding\n      nx1 = node.x - nr\n      nx2 = node.x + nr\n      ny1 = node.y - nr\n      ny2 = node.y + nr\n      quadtree.visit (quad, x1, y1, x2, y2) ->\n        if quad.point and (quad.point isnt node)\n          x = node.x - quad.point.x\n          y = node.y - quad.point.y\n          l = Math.sqrt x * x + y * y\n          r = nr + quad.point[radiusKey] # can add even more padding here\n          if l < r\n            l = (l - r) / l * alpha\n            node.x -= x *= l\n            node.y -= y *= l\n            quad.point.x += x\n            quad.point.y += y\n        x1 > nx2 or x2 < nx1 or y1 > ny2 or y2 < ny1\n\n  return d3\n\nmodule.factory 'bMapDataSvc', ($filter, $q, d3map, topojson, bDataSvc, bTopojsonSvc) ->\n  parseData = (data) ->\n    _deferred = $q.defer()\n\n    countryData = data[0].data.geo\n    topojsonData = data[1].data # $http returns other stuff w/ data\n\n    maxUsers = d3map.max countryData, (country) -> country.users\n    maxDensity = d3map.max countryData, (country) -> country.density\n    minDensity = d3map.min countryData, (country) -> country.density\n\n    colorsUsers = d3.scale.log()\n      .domain [2, maxUsers] # backend excludes countries w/ users <2\n      .range [\"#00acee\", \"#EF5734\"]\n    colorsDensity = d3map.scale.log()\n      .domain [minDensity, maxDensity]\n      .range [\"#00acee\", \"#EF5734\"]\n    radiusUsers = d3map.scale.sqrt()\n      .domain [2, maxUsers]\n      .range [2, 50]\n    radiusDensity = d3map.scale.sqrt()\n      .domain [minDensity, maxDensity]\n      .range [2, 40]\n\n    topo = topojson.feature topojsonData, topojsonData.objects.countries\n    countryDataTopo = topo.features\n      .filter (d) ->\n        countryData.some (country) -> country.isoCode is d.id\n      .map (d) ->\n        # ES6 array.find supported in FF & Chrome but not IE\n        bowerData = $filter('filter')(countryData, {isoCode: d.id})[0]\n        d.data = bowerData\n        d.rDensity = if bowerData then radiusDensity bowerData.density else 0\n        d.rUsers = if bowerData then radiusUsers bowerData.users else 0\n        d\n\n    _deferred.resolve {\n      topo: topo\n      topojsonData: topojsonData\n      colorsUsers: colorsUsers\n      colorsDensity: colorsDensity\n      radiusUsers: radiusUsers\n      radiusDensity: radiusDensity\n      countryDataTopo: countryDataTopo\n    }\n    _deferred.promise\n\n  $q.all([bDataSvc.fetchAllP, bTopojsonSvc]).then parseData\n\nmodule.directive \"bMap\", (d3map, topojson, bMapDataSvc, $window) ->\n  templateUrl: 'b-map/b-map.html'\n  restrict: 'E'\n  link: (scope, ele) ->\n    tick = null\n    scope.chartType = \"Density\"\n    scope.zoomed = false\n    scope.$watch 'chartType', (chartType, chartTypeOld) ->\n      if chartType != chartTypeOld\n        radiusKey = 'r' + chartType\n\n        svg.selectAll \".label\"\n          .text (d) -> d.data.isoCode if d[radiusKey] >= bubbleRBreaks.sm\n          .attr \"class\", \"label\" # removes all other classes\n          # TODO: change text size here so transition works, vs. doing it in CSS\n          .classed \"sm\", (d) -> d[radiusKey] <= bubbleRBreaks.md\n          .classed \"md\", (d) -> d[radiusKey] > bubbleRBreaks.md and d[radiusKey] <= bubbleRBreaks.lg\n          .classed \"lg\", (d) -> d[radiusKey] > bubbleRBreaks.lg\n\n        svg.selectAll \".bubble\"\n          .transition().duration transitionDuration\n          .attr \"r\", (d) -> d[radiusKey]\n          .attr \"fill\", (d) -> scope.data[\"colors\" + chartType] d.data[chartType.toLowerCase()]\n\n        force.start()\n\n      return\n\n    bubblePadding = 1 # for collision detection\n    bubbleOverBorder = 5 # allow bubbles to go out of bounding box a bit but not too much, see tick()\n    bubbleRBreaks = sm: 10, md: 15, lg: 20 # for setting font sizes in bubbles\n\n    transitionDuration = 250\n\n    canvas = ele[0].querySelector \".b-map\"\n    # d3.select(canvas).node().offsetWidth doesn't work in FF\n    w = canvas.clientWidth\n    h = canvas.clientHeight\n    svg = d3map.select(canvas).append(\"svg\").attr(\"width\", w).attr(\"height\", h).classed(\"svg-map\", true)\n\n    projection = d3map.geo.equirectangular()\n      .scale 160 # default to 150\n      .translate [w / 2.1, h / 1.55] # move a little to the left & down to accommodate for europe\n      # .precision(.1) # default Math.SQRT(1/2) = .5\n    path = d3map.geo.path().projection projection\n\n    force = d3map.layout.force()\n      .gravity 0 # disable, implemented elsewhere\n      .size [w * 2, h * 2]\n\n    # custom gravity function to draw nodes to original x0/y0 position instead of center of chart\n    gravity = (k) -> (d) ->\n      d.x += (d.x0 - d.x) * k\n      d.y += (d.y0 - d.y) * k\n\n    render = (data) ->\n      scope.data = data\n      # compute centroid for each country, can't do it in data due to not having path func\n      data.countryDataTopo = data.countryDataTopo.map (d) ->\n        centroid = path.centroid d.geometry # returns x/y\n        d.x = centroid[0]; d.y = centroid[1]\n        d.x0 = centroid[0]; d.y0 = centroid[1]\n        d\n\n      landContainer = svg.append(\"g\").attr \"class\", \"container land\"\n      # land polygon\n      landContainer.append(\"path\").datum(data.topo).attr(\"class\", \"land\").attr \"d\", path\n      # country boundary mesh\n      landContainer.append(\"path\")\n        .datum topojson.mesh data.topojsonData, data.topojsonData.objects.countries, (a, b) -> a isnt b\n        .attr \"class\", \"country-boundary\"\n        .attr \"d\", path\n\n      countryContainer = svg.append(\"g\").attr \"class\", \"container countries\"\n      countries = countryContainer.selectAll \"g\"\n          .data data.countryDataTopo\n        .enter().append \"g\"\n          .attr \"class\", \"country\"\n          .attr \"id\", (d) -> d.data.isoCode\n      countryBubbles = countries.append \"circle\"\n        .attr \"class\", \"bubble\"\n        .attr \"r\", (d) -> d.rDensity\n        .attr \"fill\", (d) -> data.colorsDensity d.data.density\n      countryLabels = countries.append \"text\"\n        .text (d) -> d.data.isoCode if d.rDensity >= bubbleRBreaks.sm\n        .attr \"class\", \"label\"\n        .classed \"sm\", (d) -> d.rDensity <= bubbleRBreaks.md\n        .classed \"md\", (d) -> d.rDensity > bubbleRBreaks.md and d.rDensity <= bubbleRBreaks.lg\n        .classed \"lg\", (d) -> d.rDensity > bubbleRBreaks.lg\n\n      zoom = ->\n        if (!scope.zoomed)\n          x = d3map.mouse(this)[0]\n          y = d3map.mouse(this)[1]\n          k = 3\n          scope.zoomed = true\n        else\n          x = w / 2\n          y = h / 2\n          k = 1\n          scope.zoomed = false\n\n        landContainer.transition()\n          .duration(750)\n          .attr \"transform\", \"translate(\" + w / 2 + \",\" + h / 2 + \")scale(\" + k + \")translate(\" + -x + \",\" + -y + \")\"\n          .style \"stroke-width\", 1.5 / k + \"px\"\n\n        countryContainer.transition()\n          .duration(750)\n          .attr \"transform\", \"translate(\" + w / 2 + \",\" + h / 2 + \")scale(\" + k + \")translate(\" + -x + \",\" + -y + \")\"\n          .style \"stroke-width\", 1.5 / k + \"px\"\n\n        return\n\n      landContainer.selectAll(\"path\").on(\"click\", zoom)\n      countryContainer.selectAll(\"g\").on(\"click\", zoom)\n\n      fitScreen = ->\n        w = canvas.clientWidth\n        d3map.select(\".svg-map\")\n          .attr \"width\", w\n          .attr \"height\", h\n        d3map.behavior.zoom().center [ w / 2, h / 2 ]\n        return\n\n      $window.onresize = -> fitScreen()\n\n      tick = (e) ->\n        radiusKey = 'r' + scope.chartType\n        # cx / cy constrained so bubbles go out of bounding box a bit (10) but not too much\n        countryBubbles\n          .each gravity e.alpha * .1 # custom gravity function to draw nodes to original x0/y0 position instead of center of chart\n          .each d3map.collision .2, scope.data.countryDataTopo, scope.chartType, bubblePadding\n          .attr \"cx\", (d) -> Math.max d[radiusKey], (Math.min w - d[radiusKey], d.x) + bubbleOverBorder\n          .attr \"cy\", (d) -> Math.max d[radiusKey] - bubbleOverBorder, Math.min h - d[radiusKey], d.y\n        countryLabels\n          .attr \"x\", (d) -> Math.max d[radiusKey], (Math.min w - d[radiusKey], d.x) + bubbleOverBorder\n          .attr \"y\", (d) ->\n            res = Math.max d[radiusKey] - bubbleOverBorder, Math.min h - d[radiusKey], d.y\n            if d[radiusKey] <= bubbleRBreaks.md then res + 3 else if d[radiusKey] > bubbleRBreaks.md and d[radiusKey] <= bubbleRBreaks.lg then res + 4 else res + 6\n        return\n\n      force.nodes(countryBubbles[0]).on(\"tick\", tick).start()\n      return\n\n    bMapDataSvc.then render\n    return\n","(function() {\n  var module;\n\n  module = angular.module('B.Map', []);\n\n  module.factory('topojson', function() {\n    return topojson;\n  });\n\n  module.factory('bTopojsonSvc', function($http) {\n    return $http.get('../dist/ne_110m_admin_0_countries_topojson.json');\n  });\n\n  module.factory('d3map', function(d3) {\n    d3.collision = function(alpha, nodes, radiusKey, bubblePadding, w, h) {\n      var quadtree;\n      radiusKey = 'r' + radiusKey;\n      quadtree = d3.geom.quadtree(nodes);\n      return function(node) {\n        var nr, nx1, nx2, ny1, ny2;\n        nr = node[radiusKey] + bubblePadding;\n        nx1 = node.x - nr;\n        nx2 = node.x + nr;\n        ny1 = node.y - nr;\n        ny2 = node.y + nr;\n        return quadtree.visit(function(quad, x1, y1, x2, y2) {\n          var l, r, x, y;\n          if (quad.point && (quad.point !== node)) {\n            x = node.x - quad.point.x;\n            y = node.y - quad.point.y;\n            l = Math.sqrt(x * x + y * y);\n            r = nr + quad.point[radiusKey];\n            if (l < r) {\n              l = (l - r) / l * alpha;\n              node.x -= x *= l;\n              node.y -= y *= l;\n              quad.point.x += x;\n              quad.point.y += y;\n            }\n          }\n          return x1 > nx2 || x2 < nx1 || y1 > ny2 || y2 < ny1;\n        });\n      };\n    };\n    return d3;\n  });\n\n  module.factory('bMapDataSvc', function($filter, $q, d3map, topojson, bDataSvc, bTopojsonSvc) {\n    var parseData;\n    parseData = function(data) {\n      var colorsDensity, colorsUsers, countryData, countryDataTopo, maxDensity, maxUsers, minDensity, radiusDensity, radiusUsers, topo, topojsonData, _deferred;\n      _deferred = $q.defer();\n      countryData = data[0].data.geo;\n      topojsonData = data[1].data;\n      maxUsers = d3map.max(countryData, function(country) {\n        return country.users;\n      });\n      maxDensity = d3map.max(countryData, function(country) {\n        return country.density;\n      });\n      minDensity = d3map.min(countryData, function(country) {\n        return country.density;\n      });\n      colorsUsers = d3.scale.log().domain([2, maxUsers]).range([\"#00acee\", \"#EF5734\"]);\n      colorsDensity = d3map.scale.log().domain([minDensity, maxDensity]).range([\"#00acee\", \"#EF5734\"]);\n      radiusUsers = d3map.scale.sqrt().domain([2, maxUsers]).range([2, 50]);\n      radiusDensity = d3map.scale.sqrt().domain([minDensity, maxDensity]).range([2, 40]);\n      topo = topojson.feature(topojsonData, topojsonData.objects.countries);\n      countryDataTopo = topo.features.filter(function(d) {\n        return countryData.some(function(country) {\n          return country.isoCode === d.id;\n        });\n      }).map(function(d) {\n        var bowerData;\n        bowerData = $filter('filter')(countryData, {\n          isoCode: d.id\n        })[0];\n        d.data = bowerData;\n        d.rDensity = bowerData ? radiusDensity(bowerData.density) : 0;\n        d.rUsers = bowerData ? radiusUsers(bowerData.users) : 0;\n        return d;\n      });\n      _deferred.resolve({\n        topo: topo,\n        topojsonData: topojsonData,\n        colorsUsers: colorsUsers,\n        colorsDensity: colorsDensity,\n        radiusUsers: radiusUsers,\n        radiusDensity: radiusDensity,\n        countryDataTopo: countryDataTopo\n      });\n      return _deferred.promise;\n    };\n    return $q.all([bDataSvc.fetchAllP, bTopojsonSvc]).then(parseData);\n  });\n\n  module.directive(\"bMap\", function(d3map, topojson, bMapDataSvc, $window) {\n    return {\n      templateUrl: 'b-map/b-map.html',\n      restrict: 'E',\n      link: function(scope, ele) {\n        var bubbleOverBorder, bubblePadding, bubbleRBreaks, canvas, force, gravity, h, path, projection, render, svg, tick, transitionDuration, w;\n        tick = null;\n        scope.chartType = \"Density\";\n        scope.zoomed = false;\n        scope.$watch('chartType', function(chartType, chartTypeOld) {\n          var radiusKey;\n          if (chartType !== chartTypeOld) {\n            radiusKey = 'r' + chartType;\n            svg.selectAll(\".label\").text(function(d) {\n              if (d[radiusKey] >= bubbleRBreaks.sm) {\n                return d.data.isoCode;\n              }\n            }).attr(\"class\", \"label\").classed(\"sm\", function(d) {\n              return d[radiusKey] <= bubbleRBreaks.md;\n            }).classed(\"md\", function(d) {\n              return d[radiusKey] > bubbleRBreaks.md && d[radiusKey] <= bubbleRBreaks.lg;\n            }).classed(\"lg\", function(d) {\n              return d[radiusKey] > bubbleRBreaks.lg;\n            });\n            svg.selectAll(\".bubble\").transition().duration(transitionDuration).attr(\"r\", function(d) {\n              return d[radiusKey];\n            }).attr(\"fill\", function(d) {\n              return scope.data[\"colors\" + chartType](d.data[chartType.toLowerCase()]);\n            });\n            force.start();\n          }\n        });\n        bubblePadding = 1;\n        bubbleOverBorder = 5;\n        bubbleRBreaks = {\n          sm: 10,\n          md: 15,\n          lg: 20\n        };\n        transitionDuration = 250;\n        canvas = ele[0].querySelector(\".b-map\");\n        w = canvas.clientWidth;\n        h = canvas.clientHeight;\n        svg = d3map.select(canvas).append(\"svg\").attr(\"width\", w).attr(\"height\", h).classed(\"svg-map\", true);\n        projection = d3map.geo.equirectangular().scale(160).translate([w / 2.1, h / 1.55]);\n        path = d3map.geo.path().projection(projection);\n        force = d3map.layout.force().gravity(0).size([w * 2, h * 2]);\n        gravity = function(k) {\n          return function(d) {\n            d.x += (d.x0 - d.x) * k;\n            return d.y += (d.y0 - d.y) * k;\n          };\n        };\n        render = function(data) {\n          var countries, countryBubbles, countryContainer, countryLabels, fitScreen, landContainer, zoom;\n          scope.data = data;\n          data.countryDataTopo = data.countryDataTopo.map(function(d) {\n            var centroid;\n            centroid = path.centroid(d.geometry);\n            d.x = centroid[0];\n            d.y = centroid[1];\n            d.x0 = centroid[0];\n            d.y0 = centroid[1];\n            return d;\n          });\n          landContainer = svg.append(\"g\").attr(\"class\", \"container land\");\n          landContainer.append(\"path\").datum(data.topo).attr(\"class\", \"land\").attr(\"d\", path);\n          landContainer.append(\"path\").datum(topojson.mesh(data.topojsonData, data.topojsonData.objects.countries, function(a, b) {\n            return a !== b;\n          })).attr(\"class\", \"country-boundary\").attr(\"d\", path);\n          countryContainer = svg.append(\"g\").attr(\"class\", \"container countries\");\n          countries = countryContainer.selectAll(\"g\").data(data.countryDataTopo).enter().append(\"g\").attr(\"class\", \"country\").attr(\"id\", function(d) {\n            return d.data.isoCode;\n          });\n          countryBubbles = countries.append(\"circle\").attr(\"class\", \"bubble\").attr(\"r\", function(d) {\n            return d.rDensity;\n          }).attr(\"fill\", function(d) {\n            return data.colorsDensity(d.data.density);\n          });\n          countryLabels = countries.append(\"text\").text(function(d) {\n            if (d.rDensity >= bubbleRBreaks.sm) {\n              return d.data.isoCode;\n            }\n          }).attr(\"class\", \"label\").classed(\"sm\", function(d) {\n            return d.rDensity <= bubbleRBreaks.md;\n          }).classed(\"md\", function(d) {\n            return d.rDensity > bubbleRBreaks.md && d.rDensity <= bubbleRBreaks.lg;\n          }).classed(\"lg\", function(d) {\n            return d.rDensity > bubbleRBreaks.lg;\n          });\n          zoom = function() {\n            var k, x, y;\n            if (!scope.zoomed) {\n              x = d3map.mouse(this)[0];\n              y = d3map.mouse(this)[1];\n              k = 3;\n              scope.zoomed = true;\n            } else {\n              x = w / 2;\n              y = h / 2;\n              k = 1;\n              scope.zoomed = false;\n            }\n            landContainer.transition().duration(750).attr(\"transform\", \"translate(\" + w / 2 + \",\" + h / 2 + \")scale(\" + k + \")translate(\" + -x + \",\" + -y + \")\").style(\"stroke-width\", 1.5 / k + \"px\");\n            countryContainer.transition().duration(750).attr(\"transform\", \"translate(\" + w / 2 + \",\" + h / 2 + \")scale(\" + k + \")translate(\" + -x + \",\" + -y + \")\").style(\"stroke-width\", 1.5 / k + \"px\");\n          };\n          landContainer.selectAll(\"path\").on(\"click\", zoom);\n          countryContainer.selectAll(\"g\").on(\"click\", zoom);\n          fitScreen = function() {\n            w = canvas.clientWidth;\n            d3map.select(\".svg-map\").attr(\"width\", w).attr(\"height\", h);\n            d3map.behavior.zoom().center([w / 2, h / 2]);\n          };\n          $window.onresize = function() {\n            return fitScreen();\n          };\n          tick = function(e) {\n            var radiusKey;\n            radiusKey = 'r' + scope.chartType;\n            countryBubbles.each(gravity(e.alpha * .1)).each(d3map.collision(.2, scope.data.countryDataTopo, scope.chartType, bubblePadding)).attr(\"cx\", function(d) {\n              return Math.max(d[radiusKey], (Math.min(w - d[radiusKey], d.x)) + bubbleOverBorder);\n            }).attr(\"cy\", function(d) {\n              return Math.max(d[radiusKey] - bubbleOverBorder, Math.min(h - d[radiusKey], d.y));\n            });\n            countryLabels.attr(\"x\", function(d) {\n              return Math.max(d[radiusKey], (Math.min(w - d[radiusKey], d.x)) + bubbleOverBorder);\n            }).attr(\"y\", function(d) {\n              var res;\n              res = Math.max(d[radiusKey] - bubbleOverBorder, Math.min(h - d[radiusKey], d.y));\n              if (d[radiusKey] <= bubbleRBreaks.md) {\n                return res + 3;\n              } else if (d[radiusKey] > bubbleRBreaks.md && d[radiusKey] <= bubbleRBreaks.lg) {\n                return res + 4;\n              } else {\n                return res + 6;\n              }\n            });\n          };\n          force.nodes(countryBubbles[0]).on(\"tick\", tick).start();\n        };\n        bMapDataSvc.then(render);\n      }\n    };\n  });\n\n}).call(this);\n"],"sourceRoot":"/source/"}