{"version":3,"sources":["b-chart-users/b-chart-users.coffee","b-chart-users/b-chart-users.js"],"names":[],"mappings":"AAAA;EAAA;;EAAA;;EAGA,gBAAe,iBAAA,GAAqB,yBAAA;IAClC;IAAA;MAGE;MAAA;QCGI;MDH6B;MACjC;MCKE;QACE;UDJF;UACA;UACA;UACA;QCME;MDViB;IALV;IAWb;MACE;MAAA;MAEA;MACA;QCQI;MDRiB;MACrB;MACA;MACA;MACA;MACA;QACE;MCUA;MACA;IDrBQ;IAaZ;MACE;MAAA;MACA;MACA;QCYI;QDXF;QACA;QACA;UACE;UACA;UACA;QCaA;MDnBJ;MCqBE;IDxBY;IC0Bd;EDnDgC,CAApC,CAAA;;EAuCA,kBAAiB,WAAA,GAAe,4BAAA;ICgB5B;MDfF;MACA;MACA;QACE;QAAA;UACE;UAAA;YCmBM;UDlBI;YCoBJ;UDnBD;YCqBC;UDpBD;UAGL;UACA;UACA;UACA;UAEA;UACA;UACA;UAGA;UAEA;UACA;UACA;UAEA;UAIA;UACA;YCYM;UDZG;UACT;UACA;UAEA;UACA;UACA;UACA;UAEA;UACA;YAG2B;cCUnB;YACF;cACE;YACF;UDbc;UACpB;UAIA;UAKA;UACA;QApDO;QA2DT;MA5DO;ICgEP;EDnE4B,CAAhC,CAAA;;ACsEA","file":"b-chart-users/b-chart-users.js","sourcesContent":["module = angular.module 'B.Chart.Users', []\n\n\nmodule.service 'bChartUserDataSvc', ($q, bDataSvc, d3) ->\n  parseArray = (dataArr) ->\n    # in: [key, dateStr, val]\n    # out: {key: str, date: date, val: num, movingAvg: num}\n    mAvg = movingAverage(dataArr, 7, (d) -> d[2])\n    parseDate = d3.time.format(\"%Y%m%d\").parse # e.g. 20140301\n    dataArr.slice(6).map (d, i) ->\n      key: d[0]\n      date: parseDate d[1]\n      val: d[2]\n      movingAvg: mAvg[i]\n\n  parseData = (data) ->\n    _deferred = $q.defer()\n\n    data = data.data.users\n    data = d3.nest().key((d) -> d[0]).entries data # group by key; apply to data\n    newUsersData      = parseArray data[0].values\n    existingUsersData = parseArray data[1].values\n    npmInstallsData   = parseArray data[2].values\n    data = [newUsersData, existingUsersData, npmInstallsData]\n    _deferred.resolve\n      data: data\n    _deferred.promise\n\n  movingAverage = (dataArr, numDaysToAverage, accessor) ->\n    stack = []\n    out = []\n    for d in dataArr\n      x = if accessor? then accessor(d) else d\n      stack.unshift(x)\n      if stack.length == numDaysToAverage\n        avg = d3.sum(stack) / numDaysToAverage\n        out.push(avg)\n        stack.pop()\n    out\n\n  bDataSvc.fetchAllP.then parseData\n\nmodule.directive \"bChartUsers\", (d3, bChartUserDataSvc) ->\n  templateUrl: 'b-chart-users/b-chart-users.html'\n  restrict: 'E'\n  compile: -> # no need to access element due to svg element hardcoded in html partial\n    render = (data) ->\n      stack = d3.layout.stack()\n        .values (d) -> d\n        .x (d) -> d.date\n        .y (d) -> d.movingAvg\n        .order \"reverse\"\n\n      stackedData = stack data.data.slice 0, 2\n      newUsersData = stackedData[0]\n      existingUsersData = stackedData[1]\n      npmData = data.data[2]\n\n      xScale = new Plottable.Scale.Time()\n      yScaleUsers    = new Plottable.Scale.Linear()\n      yScaleInstalls = new Plottable.Scale.Linear()\n\n      # disable auto-padding on the date axis since it looks ugly when compared with areaPlots\n      xScale.domainer new Plottable.Domainer().pad(0)\n      # Make sure the yScales both include 0 and add padding on top. Also, they look better w/ fewer ticks\n      domainer = new Plottable.Domainer().addIncludedValue(0).pad(0.2).addPaddingException(0)\n      yScaleUsers.domainer(domainer).ticks(5)\n      yScaleInstalls.domainer(domainer).ticks(5)\n\n      colorScale = (new Plottable.Scale.Color()) # Only used to generate legend right now\n        .domain [\"New Users\", \"Existing Users\", \"npm Installs\"]\n        .range [\"#00acee\", \"#ffcc2f\", \"#EF5734\"]\n\n      xAxis         = new Plottable.Axis.Time xScale, \"bottom\"\n      format = (n) -> Math.round(n/1000).toString() + \"k\"\n      yAxisUsers    = new Plottable.Axis.Numeric yScaleUsers, \"left\", format\n      yAxisInstalls = new Plottable.Axis.Numeric yScaleInstalls, \"right\", format\n\n      gridlines     = new Plottable.Component.Gridlines xScale, yScaleUsers\n      legend        = new Plottable.Component.Legend(colorScale).xAlign \"left\"\n      usersLabel    = new Plottable.Component.AxisLabel \"Daily Active Users\", \"left\"\n      installsLabel = new Plottable.Component.AxisLabel \"Daily npm Installs\", \"left\"\n\n      stackedAreaPlot_users = new Plottable.Plot.StackedArea xScale, yScaleUsers\n      stackedAreaPlot_users\n        .addDataset \"existing\", existingUsersData\n        .addDataset \"new\", newUsersData\n        .project \"fill\", ((d) -> if d.key is 'N' then 1 else 2), colorScale\n      stackedAreaPlot_users\n        .project(\"x\", \"date\", xScale)\n        .project(\"y0\", \"y0\", yScaleUsers)\n\n      line_installs = (new Plottable.Plot.Line(npmData, xScale, yScaleInstalls))\n        .project(\"x\", \"date\", xScale)\n        .project(\"y\", \"movingAvg\", yScaleInstalls)\n        .classed(\"npm-installs\", true);\n\n      center = stackedAreaPlot_users.merge(line_installs).merge(gridlines).merge(legend)\n      chart = new Plottable.Component.Table([\n          [usersLabel, yAxisUsers, center     , yAxisInstalls, installsLabel],\n          [null      , null      , xAxis      , null         , null         ]\n        ]).renderTo(\"#users-chart\");\n\n      return\n\n    bChartUserDataSvc.then render\n    return\n","(function() {\n  var module;\n\n  module = angular.module('B.Chart.Users', []);\n\n  module.service('bChartUserDataSvc', function($q, bDataSvc, d3) {\n    var movingAverage, parseArray, parseData;\n    parseArray = function(dataArr) {\n      var mAvg, parseDate;\n      mAvg = movingAverage(dataArr, 7, function(d) {\n        return d[2];\n      });\n      parseDate = d3.time.format(\"%Y%m%d\").parse;\n      return dataArr.slice(6).map(function(d, i) {\n        return {\n          key: d[0],\n          date: parseDate(d[1]),\n          val: d[2],\n          movingAvg: mAvg[i]\n        };\n      });\n    };\n    parseData = function(data) {\n      var existingUsersData, newUsersData, npmInstallsData, _deferred;\n      _deferred = $q.defer();\n      data = data.data.users;\n      data = d3.nest().key(function(d) {\n        return d[0];\n      }).entries(data);\n      newUsersData = parseArray(data[0].values);\n      existingUsersData = parseArray(data[1].values);\n      npmInstallsData = parseArray(data[2].values);\n      data = [newUsersData, existingUsersData, npmInstallsData];\n      _deferred.resolve({\n        data: data\n      });\n      return _deferred.promise;\n    };\n    movingAverage = function(dataArr, numDaysToAverage, accessor) {\n      var avg, d, out, stack, x, _i, _len;\n      stack = [];\n      out = [];\n      for (_i = 0, _len = dataArr.length; _i < _len; _i++) {\n        d = dataArr[_i];\n        x = accessor != null ? accessor(d) : d;\n        stack.unshift(x);\n        if (stack.length === numDaysToAverage) {\n          avg = d3.sum(stack) / numDaysToAverage;\n          out.push(avg);\n          stack.pop();\n        }\n      }\n      return out;\n    };\n    return bDataSvc.fetchAllP.then(parseData);\n  });\n\n  module.directive(\"bChartUsers\", function(d3, bChartUserDataSvc) {\n    return {\n      templateUrl: 'b-chart-users/b-chart-users.html',\n      restrict: 'E',\n      compile: function() {\n        var render;\n        render = function(data) {\n          var center, chart, colorScale, domainer, existingUsersData, format, gridlines, installsLabel, legend, line_installs, newUsersData, npmData, stack, stackedAreaPlot_users, stackedData, usersLabel, xAxis, xScale, yAxisInstalls, yAxisUsers, yScaleInstalls, yScaleUsers;\n          stack = d3.layout.stack().values(function(d) {\n            return d;\n          }).x(function(d) {\n            return d.date;\n          }).y(function(d) {\n            return d.movingAvg;\n          }).order(\"reverse\");\n          stackedData = stack(data.data.slice(0, 2));\n          newUsersData = stackedData[0];\n          existingUsersData = stackedData[1];\n          npmData = data.data[2];\n          xScale = new Plottable.Scale.Time();\n          yScaleUsers = new Plottable.Scale.Linear();\n          yScaleInstalls = new Plottable.Scale.Linear();\n          xScale.domainer(new Plottable.Domainer().pad(0));\n          domainer = new Plottable.Domainer().addIncludedValue(0).pad(0.2).addPaddingException(0);\n          yScaleUsers.domainer(domainer).ticks(5);\n          yScaleInstalls.domainer(domainer).ticks(5);\n          colorScale = (new Plottable.Scale.Color()).domain([\"New Users\", \"Existing Users\", \"npm Installs\"]).range([\"#00acee\", \"#ffcc2f\", \"#EF5734\"]);\n          xAxis = new Plottable.Axis.Time(xScale, \"bottom\");\n          format = function(n) {\n            return Math.round(n / 1000).toString() + \"k\";\n          };\n          yAxisUsers = new Plottable.Axis.Numeric(yScaleUsers, \"left\", format);\n          yAxisInstalls = new Plottable.Axis.Numeric(yScaleInstalls, \"right\", format);\n          gridlines = new Plottable.Component.Gridlines(xScale, yScaleUsers);\n          legend = new Plottable.Component.Legend(colorScale).xAlign(\"left\");\n          usersLabel = new Plottable.Component.AxisLabel(\"Daily Active Users\", \"left\");\n          installsLabel = new Plottable.Component.AxisLabel(\"Daily npm Installs\", \"left\");\n          stackedAreaPlot_users = new Plottable.Plot.StackedArea(xScale, yScaleUsers);\n          stackedAreaPlot_users.addDataset(\"existing\", existingUsersData).addDataset(\"new\", newUsersData).project(\"fill\", (function(d) {\n            if (d.key === 'N') {\n              return 1;\n            } else {\n              return 2;\n            }\n          }), colorScale);\n          stackedAreaPlot_users.project(\"x\", \"date\", xScale).project(\"y0\", \"y0\", yScaleUsers);\n          line_installs = (new Plottable.Plot.Line(npmData, xScale, yScaleInstalls)).project(\"x\", \"date\", xScale).project(\"y\", \"movingAvg\", yScaleInstalls).classed(\"npm-installs\", true);\n          center = stackedAreaPlot_users.merge(line_installs).merge(gridlines).merge(legend);\n          chart = new Plottable.Component.Table([[usersLabel, yAxisUsers, center, yAxisInstalls, installsLabel], [null, null, xAxis, null, null]]).renderTo(\"#users-chart\");\n        };\n        bChartUserDataSvc.then(render);\n      }\n    };\n  });\n\n}).call(this);\n"],"sourceRoot":"/source/"}